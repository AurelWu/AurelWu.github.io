<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HexMapLibrary: Minimal Example 4: a wrapping Map</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HexMapLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">HexMap Library Documentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Minimal Example 4: a wrapping Map </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we will recreate Example 1 but this time on a wrapping map. To do that we have to take care of 2 aspects: <br />
1) the wrapping logic - the library will take care of that <br />
 2) visualising the map. The primary issue here is that because the map repeats itself we can not just have a tile in 1 static position.</p>
<p>We will use Example 1 as starting point and just change a few things. Let's start with the wrapping logic, this will be the easy part. The Constructor of the HexMap class can be optionally provided with a CoordinateWrapper so let's create one. For this example what we want to do is create a rectangular shaped map and have the map wrap around horizontally, like it is common in games like Civilization. The Library includes an implementation which does just that. In the Start method we just need to replace :</p>
<div class="fragment"><div class="line">hexMap = <span class="keyword">new</span> HexMap&lt;int,int&gt;(MapShape.CreateRectangularShapedMap(mapSize),<span class="stringliteral">&quot;MyMap&quot;</span>); </div></div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line">CoordinateWrapper coordinateWrapper = <span class="keyword">new</span> CoordinateWrapperRectangularHorizonalPeriodic(mapSize.x);</div><div class="line">hexMap = <span class="keyword">new</span> HexMap&lt;int,int&gt;(MapShape.CreateRectangularShapedMap(mapSize),<span class="stringliteral">&quot;MyMap&quot;</span>,coordinateWrapper)</div></div><!-- fragment --><p> You can easily create other coordinateWrappers for the mapShape and behaviour you need by deriving from the abstract CoordinateWrapper class.</p>
<p>If we start play mode in the current state and move the mouse cursor left or right outside the map boundaries you will see that a tile on the other side of the map will get marked and if you click it will change that tile. So from a functional point we are finished and while for some games this might be sufficient usually you want the visuals to also repeat themselves.</p>
<p>There are countless approaches for that and the one presented here is a very basic one which does not account for all edge cases and has the limitation that it only works when the map is at least two times as wide as the camera can see. However, it serves as a starting point for you and while the following code is absolutely unrelated to the library itself, it hopefully will prove helpful for many.</p>
<p>To actually test if what we want to do is working, we obviously need some control with which we can move the camera, so we create a simple CameraMovement script:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MinimalExample4GenericCamera : MonoBehaviour</div><div class="line">{</div><div class="line">    [SerializeField]</div><div class="line">    <span class="keyword">private</span> <span class="keywordtype">float</span> panSpeed = 4;</div><div class="line">    <span class="keyword">private</span> <span class="keywordtype">float</span> maxY; <span class="comment">//we clamp the camera so we never move too far off map</span></div><div class="line">    <span class="keyword">private</span> <span class="keywordtype">float</span> minY; <span class="comment">//we clamp the camera so we never move too far off map</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> Init(HexMap&lt;int, int&gt; hexMap)</div><div class="line">    {</div><div class="line">        maxY = hexMap.Center.z + (hexMap.MapBoundingBoxSize.y * 0.75f) - Camera.main.orthographicSize + 1; <span class="comment">//+1 gives a bit of room at the top</span></div><div class="line">        minY = hexMap.Center.z - (hexMap.MapBoundingBoxSize.y * 0.75f) + Camera.main.orthographicSize - 1; <span class="comment">//-1 give a bit of room at the bottom</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> LateUpdate()</div><div class="line">    {</div><div class="line">        <span class="keywordtype">float</span> inputHorizontal = Input.GetAxis(<span class="stringliteral">&quot;Horizontal&quot;</span>);</div><div class="line">        <span class="keywordtype">float</span> inputVertical = Input.GetAxis(<span class="stringliteral">&quot;Vertical&quot;</span>);</div><div class="line"></div><div class="line">        Vector3 movement = <span class="keyword">new</span> Vector3(inputHorizontal, inputVertical, 0);</div><div class="line"></div><div class="line">        transform.position = transform.position + <span class="keyword">new</span> Vector3(inputHorizontal, 0, inputVertical) * Time.deltaTime * panSpeed;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (transform.position.z &lt; minY) transform.position = <span class="keyword">new</span> Vector3(transform.position.x, transform.position.y, minY);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transform.position.z &gt; maxY) transform.position = <span class="keyword">new</span> Vector3(transform.position.x, transform.position.y, maxY);</div><div class="line"></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>You can either attach that script to the main camera in the inspector or add it in code with mainCamera.gameObject.AddComponent&lt;MinimalExample4GenericCamera&gt;();</p>
<p>What we will do next is split the map in 2 parts : a "left" half of the map , and a "right" half of the map. We then will move those map parts around to create an illusion that you can go in 1 direction infinitely and the map is just repeating itself. We will also "teleport" the map and camera back in direction of the center once we are too far away, to prevent going floating point errors becoming too big. (Because of the way floating point numbers work, the further away you get from 0 the more imprecise they become).</p>
<p>We will use 2 empty gameObjects which will serve as parents to the left/right tiles. So instead of moving every single tile around we will only need to move the parents. <br />
 We will also calculate the positions at which we move the tile-groups and at which we move the camera back towards the center.</p>
<div class="fragment"><div class="line"><span class="comment">//[...]</span></div><div class="line"><span class="keyword">private</span> GameObject leftMapHalfTransformParent;</div><div class="line"><span class="keyword">private</span> GameObject rightMapHalfTransformParent;</div><div class="line"><span class="keyword">private</span> <span class="keywordtype">float</span> mapWidth;</div><div class="line"><span class="keyword">private</span> <span class="keywordtype">float</span> leftJumpPoint; <span class="comment">// if camera Position &lt; leftJumpPoint move RIGHT map half 1 mapWidth to left;</span></div><div class="line"><span class="keyword">private</span> <span class="keywordtype">float</span> rightJumpPoint; <span class="comment">// if camera Position &gt; rightJumpPoint move LEFT map half 1 mapWidth to right;</span></div><div class="line"><span class="keyword">private</span> <span class="keywordtype">float</span> leftCameraJumpBackPoint; <span class="comment">//if camera position &lt; leftJumpBackPoint move CAMERA 1 mapWidth to right;</span></div><div class="line"><span class="keyword">private</span> <span class="keywordtype">float</span> rightCameraJumpBackPoint; <span class="comment">//if camera position &gt; rightJumpBackPoint move CAMERA 1 mapWidth to left</span></div><div class="line"><span class="keyword">private</span> Camera mainCamera = null;</div><div class="line"><span class="comment">//[...]</span></div><div class="line"><span class="keywordtype">void</span> Start ()</div><div class="line">{</div><div class="line">    leftMapHalfTransformParent = <span class="keyword">new</span> GameObject(<span class="stringliteral">&quot;LeftMapHalf&quot;</span>); <span class="comment">// this creates an empty gameObject called &quot;LeftMapHalf&quot;</span></div><div class="line">    rightMapHalfTransformParent = <span class="keyword">new</span> GameObject(<span class="stringliteral">&quot;RightMapHalf&quot;</span>);</div><div class="line">    <span class="comment">//[...]</span></div><div class="line">    mapWidth = hexMap.MapBoundingBoxSize.x * Mathf.Sqrt(3);</div><div class="line">    leftJumpPoint = mapWidth * 0.25f;</div><div class="line">    rightJumpPoint = mapWidth * 0.75f;</div><div class="line">    leftCameraJumpBackPoint = mapWidth * -0.25f;</div><div class="line">    rightCameraJumpBackPoint = mapWidth * 1.25f;</div><div class="line">    mainCamera = Camera.Main;</div><div class="line">    <span class="comment">//[...]</span></div><div class="line">    </div><div class="line">}</div></div><!-- fragment --><p>and then when when we instantiate all the gameObjects we assign them one of those 2 gameObjects as parent:</p>
<div class="fragment"><div class="line"><span class="keywordflow">foreach</span> (var tile <span class="keywordflow">in</span> hexMap.Tiles)</div><div class="line">{</div><div class="line">    <span class="comment">//same code as in Example 1</span></div><div class="line">    tile.Data = (Random.Range(0, 4)); </div><div class="line">    GameObject instance = GameObject.Instantiate(hexPrefab);</div><div class="line">    instance.GetComponent&lt;Renderer&gt;().material = materials[tile.Data];</div><div class="line">    instance.name = <span class="stringliteral">&quot;MapTile_&quot;</span> + tile.Position;</div><div class="line">    instance.transform.position = tile.CartesianPosition;</div><div class="line">    </div><div class="line">    <span class="comment">//added assignment to parent:</span></div><div class="line">    <span class="keywordflow">if</span>(tile.NormalizedPosition.x &lt;= 0.5f)</div><div class="line">    {</div><div class="line">        instance.transform.SetParent(leftMapHalfTransformParent.transform);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        instance.transform.SetParent(rightMapHalfTransformParent.transform);</div><div class="line">    }</div><div class="line">    tileObjects[tile.Index] = instance;</div><div class="line">}</div></div><!-- fragment --><p>now what is missing is the method which moves the tile-groups around, we will create a "UpdateMapWrap" Method which will be called on every Update:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> UpdateWrapPositioning()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> cameraX = mainCamera.transform.position.x;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cameraX &lt; leftCameraJumpBackPoint)</div><div class="line">    {</div><div class="line">        mainCamera.transform.position += <span class="keyword">new</span> Vector3(mapWidth, 0, 0);</div><div class="line">        cameraX = mainCamera.transform.position.x;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cameraX &gt; rightCameraJumpBackPoint)</div><div class="line">    {</div><div class="line">        mainCamera.transform.position -= <span class="keyword">new</span> Vector3(mapWidth, 0, 0);</div><div class="line">        cameraX = mainCamera.transform.position.x;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cameraX &lt; leftJumpPoint)</div><div class="line">    {</div><div class="line">        rightMapHalfTransformParent.transform.position = <span class="keyword">new</span> Vector3(-mapWidth, 0, 0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> rightMapHalfTransformParent.transform.position = Vector3.zero;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cameraX &gt; rightJumpPoint)</div><div class="line">    {</div><div class="line">        leftMapHalfTransformParent.transform.position = <span class="keyword">new</span> Vector3(mapWidth, 0, 0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> leftMapHalfTransformParent.transform.position = Vector3.zero;</div><div class="line">}</div></div><!-- fragment --><p>And we are done :-) As with the others, the completed example scene is included! </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
