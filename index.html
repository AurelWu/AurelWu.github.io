<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HexMapLibrary: HexMap Library Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HexMapLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HexMap Library Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="BannerCombined.png" alt="BannerCombined.png"/>
</div>
 <h3>Introduction</h3>
<p>This library makes working with hexagonal grids and maps an intuitive, easy and maybe even fun process. <br />
All the details of hexagonal-grid-coordinate systems and the mathematics behind it are abstracted away from you so you can focus on building your game logic using declarative statements. <br />
We <b>include multiple example scenes</b> displaying some approaches how the library can be used and showing how easily common features like line-of-sight or turn-based movement with movement costs based on map features can be implemented. <br />
<b>At the bottom of this page you will find step-by-step walkthroughs for the first three examples.</b></p>
<p>The visual representation of the hexagonal map is not part of the library as that is highly implementation specific. The sample scenes however come with some very basic visualisations.</p>
<h3>Key Features</h3>
<ul>
<li>support for Tiles, Edges and Corners</li>
<li>supports workflows for finite maps as well as an infinite grid</li>
<li>maps can optionally be periodic (wrap around). Currently only "cylindrical" (repeating on x-axis) wrapping logic is included directly with the library but you can easily write your own wrap around logic</li>
<li>support for generics: a tile,edge or corner can have any class/struct as data type</li>
<li>alternatively derive from the non generic base class or keep the data of the game logic completely separate in arrays aligned with the tile/edge/corner indices of the HexMap</li>
<li>extensive amount of easy to use methods which can be used as building blocks to solve complex problems</li>
<li>build with ease of use as primary design</li>
<li>uses primarily "cube" coordinates. An explanation about the different coordinate systems used in this library can be found here: <a class="el" href="class_wunderwunsch_1_1_hex_map_library_1_1_hex_converter.html#details">HexConverter</a></li>
<li>fully documented API</li>
<li>source code available</li>
<li>MIT license</li>
</ul>
<h3>Downloads</h3>
<ul>
<li>from itch.io : <a href="https://aurelwu.itch.io/hexmaplibrary">https://aurelwu.itch.io/hexmaplibrary</a></li>
<li>from github (library code only without examples) : <a href="https://github.com/AurelWu/HexMapLibrary">https://github.com/AurelWu/HexMapLibrary</a></li>
</ul>
<h3>General Usage Principle</h3>
<p>The Library has a consistent method naming scheme based on their return value allowing for intuitive usage:</p>
<div class="fragment"><div class="line">result1 = map.GetTiles.Line(origin,target,<span class="keyword">true</span>); <span class="comment">//returns all tiles forming a line from origin to target (3rd param set to true specifies that the origin is included)</span></div><div class="line">result2 = map.GetEdges.AdjacentToCorner(corner); <span class="comment">//return all edges which are neighbouring the corner (usually 3 but at map border it can be just 2)</span></div><div class="line">result3 = map.GetCorners.WithinDistance(centerCorner,distance,<span class="keyword">false</span>); <span class="comment">// returns all corners which are no further than distance away from the center (3rd param set to false specifies that origin is not included)</span></div><div class="line">result4 = map.GetTileDistance.Grid(TileA,TileB); <span class="comment">// returns the grid distance between those 2 tiles (there is also GetTileDistance.Euclidean if you want the euclidean distance)</span></div><div class="line">result5 = map.GetEdge.BetweenTiles(TileA,TileB); <span class="comment">// returns the edge which is between the 2 input tiles (throws an argument exception if the input tiles are not neighbouring)</span></div></div><!-- fragment --><h3>Overview over the classes you will use mostly:</h3>
<ul>
<li>HexGrid<ul>
<li>This is a static class representing an infinite grid on the xz-plane.</li>
<li>The methods of this class form the foundation of HexMap (which then adds bound checks and wrapping logic on top).</li>
<li>often useful for intermediate steps even when the final results are on a finite-sized HexMap</li>
</ul>
</li>
<li>HexMap<ul>
<li>an instance of HexMap represents a specific map instance with a defined set of Tiles ,Edges and Corners.</li>
<li>optionally it can be periodic (i.e. wraps around at some or all the map borders)</li>
<li>takes care of all bound checks and wrapping logic</li>
</ul>
</li>
<li>HexMap&lt;T&gt;, HexMap&lt;T,E&gt;, HexMap&lt;T,E,C&gt;<ul>
<li>please note that they are called HexMapT&lt;T&gt; , HexMapTE&lt;T,E&gt; , HexMapTEC&lt;T,E,C&gt; in this documentation, this is just because the documentation generation software we use does not properly work with generics classes with different overloads and same class name. In the actual library they are all called HexMap&lt;...&gt; .</li>
<li>generic variants of HexMap in which every Tile (and Edge / Corner) is an object of arbitrary type.</li>
</ul>
</li>
<li>HexConverter<ul>
<li>static class to convert coordinates between different coordinate systems (cartesian, cube, offset)</li>
</ul>
</li>
<li>HexMapBuilder<ul>
<li>static class to easily generate rectangular ,hexagonal or triangular shaped maps.</li>
</ul>
</li>
<li>HexMouse<ul>
<li>Monobehaviour which updates information about the mouse position every frame (current tile, nearest edge, nearest corner, is cursor on map)</li>
</ul>
</li>
</ul>
<h3>About "Pointy-Top" and "Flat-Top"-Hexagons</h3>
<p>Everything in this library is build around pointy-top hexagons, however flat-top hexagons are just rotated pointy-top hexagons so you can just rotate the input and output coordinates, or even just your camera. Generally we recommend using pointy-top hexagons because you can fit more hexagons vertically this way which partly balances out the fact that computer screens are wider than tall. If you are not convinced by that, take a look at honeybees and how they build their combs. </p><div class="image">
<img src="PointyAndFlatTopHexagon.png" alt="PointyAndFlatTopHexagon.png"/>
<div class="caption">
left: pointy-top hexagon, right: flat-top hexagon</div></div>
<p> <br />
 </p><h3>Performance:</h3>
<p>While we made sure that the library does have reasonable performance we always prioritised useability and flexibility over raw performance. We made that decision because in most use cases it won't matter at all, and in those where it does, the solution will most likely be to just cache results. For example instead of always recalculating the result of HexMap.GetTiles.OfRing() which might become costly if the radius is big you can just calculate the relative position of the resulting tiles to the center once for each radius you need and store them. If you ever encounter a performance issue which is not solvable this way and you also don't find another solution, please message us and we will try to find a solution (no promises that we can solve your particular problem but we will try our best as long as it is within reasonable scope)</p>
<h3>Examples</h3>
<p>These examples are kept as simple and as possible so you can focus on the usage of the library, this code is by no means intended to be used in production code and is not suitable structured for that but for ease of understanding. You will also notice some duplicate code between them, that is consciously done to keep each example self-contained.</p>
<p>All these examples use a very simple way to visualise the map which is far from perfect in many ways, especially when it comes to performance as we use one GameObject per tile. We use custom shader which draws the hex grid lines on top of the mesh based on the world position. As this is not fundamental for the library itself we omit an explanation what this shader does in detail.</p>
<p>Please keep in mind that this library is not tied to a certain visualisation and you can easily use procedurally generated meshes, Environments created in 3D modelling software or even handpainted backgrounds instead.</p>
<p>You can either follow the tutorials step by step or take a look at the finished scene &amp; script for each example.</p>
<p>-<a class="el" href="_ex0.html">Example 0: Hello hex world</a></p>
<p>-<a class="el" href="_ex1.html">Example 1: Mouse markers and simple map manipulation</a></p>
<p>-<a class="el" href="_ex2.html">Example 2: Line of sight</a></p>
<p>There are two more scenes in the example folder, one covering path finding while the other is about building and road placement. The script files are documented so by now they are hopefully easily understood.</p>
<h3>Reading Recommendation</h3>
<p>If you want to understand hexagonal grids in depth we recommend reading Amit Patel's excellent page about hexagons: <a href="https://www.redblobgames.com/grids/hexagons/">https://www.redblobgames.com/grids/hexagons/</a></p>
<h3>License</h3>
<p>The MIT License (MIT)</p>
<p>Copyright (c) 2018 Aurel "AurelWu" Wünsch</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
