<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HexMapLibrary: Minimal Example 2: Create a Hexagonal shaped map and visualise some of the HexMap Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HexMapLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">HexMap Library Documentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Minimal Example 2: Create a Hexagonal shaped map and visualise some of the HexMap Methods </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we are going to create a HexMap with a hexagonal shape and will use a few of the available Methods in <a class="el" href="class_wunderwunsch_1_1_hex_map_library_1_1_generic_1_1_hex_map.html">HexMap</a> to select tiles and edges. <br />
 We want to visualise the following four Methods: <a class="el" href="class_wunderwunsch_1_1_hex_map_library_1_1_generic_1_1_hex_map.html#ae5452aa6ca8241f8f7e3b0c56d639346">GetNeighbourTiles()</a>, <a class="el" href="class_wunderwunsch_1_1_hex_map_library_1_1_generic_1_1_hex_map.html#a44a8db6856785c8e91878277b6a41927">GetLineTiles()</a>, <a class="el" href="class_wunderwunsch_1_1_hex_map_library_1_1_generic_1_1_hex_map.html#ad9a5d08a3c3082dac0294cb50f5c711e">GetRingTiles()</a> and <a class="el" href="class_wunderwunsch_1_1_hex_map_library_1_1_generic_1_1_hex_map.html#afdaf55b7b03d96d5e5b601db9dcb7338">GetBorderEdgesOfSetOfTiles()</a></p>
<p>Once again we are going to create a new script called "MinimalExample2" and add the library namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespace_wunderwunsch.html">Wunderwunsch</a>.<a class="code" href="namespace_wunderwunsch_1_1_hex_map_library.html">HexMapLibrary</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="namespace_wunderwunsch.html">Wunderwunsch</a>.<a class="code" href="namespace_wunderwunsch_1_1_hex_map_library.html">HexMapLibrary</a>.<a class="code" href="namespace_wunderwunsch_1_1_hex_map_library_1_1_generic.html">Generic</a>;</div></div><!-- fragment --><p>First of all we define a enum called ToolMode so when we switch between the different methods in the inspector we have nice names. You can put this in an extra file or just in the same script file. However to be visible for the inspector you need to define that enum outside of the MinimalExample2 class</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ToolMode</div><div class="line">{</div><div class="line">    Neighbours,</div><div class="line">    Line,</div><div class="line">    Ring,</div><div class="line">    GetBorderEdgesofSetOfTiles,</div><div class="line">}</div></div><!-- fragment --><p>Then we define the variables we need. We want to keep them private but for some of them it is useful to assign in the inspector therefore we add the [SerializeField] attribute.</p>
<div class="fragment"><div class="line">[SerializeField] <span class="keyword">private</span> GameObject hexPrefab = null;</div><div class="line">[SerializeField] <span class="keyword">private</span> GameObject edgePrefab = null;</div><div class="line">[SerializeField] <span class="keyword">private</span> List&lt;Material&gt; materials = null; <span class="comment">// we will use 4 different materials.</span></div><div class="line">[SerializeField] <span class="keyword">private</span> ToolMode toolMode = ToolMode.Neighbours;</div><div class="line"></div><div class="line"><span class="keyword">private</span> HexMap&lt;int,int&gt; hexMap; </div><div class="line"><span class="keyword">private</span> HexMouse hexMouse = null;</div><div class="line"><span class="keyword">private</span> GameObject[] tileObjects;</div><div class="line"><span class="keyword">private</span> List&lt;GameObject&gt; borderEdges; <span class="comment">// we will use this to keep track of the spawned edge gameObjects for the GetBorderEdgesOfSetOfTiles method</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> Tile selectedTileA;</div><div class="line"><span class="keyword">private</span> Tile selectedTileB;</div></div><!-- fragment --><p>Now it is time to create our map, which is mostly identical to the previous example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Start ()</div><div class="line">{</div><div class="line">    hexMap = <span class="keyword">new</span> HexMap&lt;int,int&gt;(MapShape.CreateHexagonalShapedMap(7),<span class="stringliteral">&quot;MyMap&quot;</span>,<span class="keyword">true</span>); <span class="comment">//in this example we actually don&#39;t use the tile or edge value at all and just directly set the material of the tiles.</span></div><div class="line">    hexMouse = gameObject.AddComponent&lt;HexMouse&gt;(); <span class="comment">//we attach the hexMouse script to the same empty gameObject this script is attached to</span></div><div class="line">    hexMouse.Init(hexMap,<span class="keyword">true</span>);</div><div class="line">    tileObjects = <span class="keyword">new</span> GameObject[hexMap.TilesByPosition.Count];</div><div class="line">    borderEdges = <span class="keyword">new</span> List&lt;GameObject&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">foreach</span> (var tile <span class="keywordflow">in</span> hexMap.Tiles)</div><div class="line">    {</div><div class="line">        GameObject instance = GameObject.Instantiate(hexPrefab);</div><div class="line">        instance.GetComponent&lt;Renderer&gt;().material = materials[0];</div><div class="line">        instance.name = <span class="stringliteral">&quot;MapTile_&quot;</span> + tile.Position;</div><div class="line">        instance.transform.position = tile.CartesianPosition;</div><div class="line">        tileObjects[tile.Index] = instance;</div><div class="line">    }</div><div class="line">    Camera.main.transform.position = <span class="keyword">new</span> Vector3(hexMap.Center.x, 5, hexMap.Center.z);</div><div class="line">    Camera.main.orthographic = <span class="keyword">true</span>;</div><div class="line">    Camera.main.orthographicSize = hexMap.MapBoundingBoxSize.y * 0.8f;</div><div class="line">    </div><div class="line">    selectedTileA = hexMap.Tiles[0];</div><div class="line">    selectedTileB = hexMap.Tiles[1];</div><div class="line">}</div></div><!-- fragment --><p>Next we write our Update() Method which checks if we clicked with the mouse, leftclick sets the origin tile and rightclick the target tile (only relevant for <a class="el" href="class_wunderwunsch_1_1_hex_map_library_1_1_generic_1_1_hex_map.html#a44a8db6856785c8e91878277b6a41927">GetLineTiles()</a> )</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Update ()</div><div class="line">   {            </div><div class="line">       Vector3Int mousePosition = hexMouse.CubeCoord;</div><div class="line">       <span class="keywordtype">bool</span> mouseIsOnMap = hexMouse.CursorIsOnMap;            </div><div class="line">       <span class="keywordflow">if</span>(mouseIsOnMap &amp;&amp; Input.GetMouseButtonDown(0)) <span class="comment">// if we leftclick while over the map</span></div><div class="line">       {</div><div class="line">           selectedTileA = hexMap.TilesByPosition[mousePosition]; <span class="comment">// we set our origin tile to the current mouse position</span></div><div class="line">           ApplyActiveTool(); <span class="comment">// we call the ApplyActiveTool() method which we will create next;</span></div><div class="line">       }</div><div class="line"></div><div class="line">       <span class="keywordflow">if</span> (mouseIsOnMap &amp;&amp; Input.GetMouseButtonDown(1)) <span class="comment">// if we rightclick while over the map</span></div><div class="line">       {</div><div class="line">           selectedTileB = hexMap.TilesByPosition[mousePosition]; <span class="comment">// we set our target tile (for line only) to the current mouse position</span></div><div class="line">           ApplyActiveTool();  <span class="comment">// we call the ApplyActiveTool() method which we will create next;</span></div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p>Finally we actually need to do something when we click, so we add the ApplyActiveTool method:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ApplyActiveTool()</div><div class="line">{            </div><div class="line">    <span class="keywordflow">foreach</span> (var tileObj <span class="keywordflow">in</span> tileObjects)</div><div class="line">    {</div><div class="line">        tileObj.GetComponent&lt;Renderer&gt;().material = materials[0]; <span class="comment">// we set every gameObject back to the default (unmarked) material</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">foreach</span>(var edgeObj <span class="keywordflow">in</span> borderEdges)</div><div class="line">    {</div><div class="line">        Destroy(edgeObj); <span class="comment">// we remove all spawned edge Gameobjects which might be on the map currently</span></div><div class="line">    }</div><div class="line">    borderEdges.Clear(); <span class="comment">// we clear the dictionary to get rid of those now deleted edge GameObjects</span></div><div class="line"></div><div class="line">    List&lt;Tile&gt; tilesToMark = <span class="keyword">new</span> List&lt;Tile&gt;();</div><div class="line">    List&lt;Edge&gt; edgesToMark = <span class="keyword">new</span> List&lt;Edge&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (toolMode) <span class="comment">//here we use the library methods to get the tiles we want to mark</span></div><div class="line">    {               </div><div class="line">        <span class="keywordflow">case</span> ToolMode.Neighbours:</div><div class="line">            tilesToMark = hexMap.GetNeighbourTiles(selectedTileA);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> ToolMode.Line:</div><div class="line">            tilesToMark = hexMap.GetLineTiles(selectedTileA, selectedTileB, -0.001f, 0, 0);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> ToolMode.Ring:</div><div class="line">            tilesToMark = hexMap.GetRingTiles(selectedTileA, 3, 1);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> ToolMode.GetBorderEdgesofSetOfTiles:</div><div class="line">            tilesToMark = hexMap.GetAllTilesWithinManhattanRange(selectedTileA, 3, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">            List&lt;Tile&gt; someMoreRandomTiles = hexMap.GetRingTiles(selectedTileA, 4, 1); </div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; someMoreRandomTiles.Count; i++)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> (Random.Range(0, 50) &gt; 20)</div><div class="line">                {</div><div class="line">                    tilesToMark.Add(someMoreRandomTiles[i]); <span class="comment">// we add some random tiles from the ring with distance 4 to origin</span></div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            edgesToMark = hexMap.GetBorderEdgesOfSetOfTiles(tilesToMark);</div><div class="line">            <span class="keywordflow">foreach</span>(Edge edge <span class="keywordflow">in</span> edgesToMark)</div><div class="line">            {</div><div class="line">                GameObject edgeObj = Instantiate(edgePrefab, edge.CartesianPosition, Quaternion.Euler(0, edge.EdgeOrientationAngle, 0));</div><div class="line">                borderEdges.Add(edgeObj);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">foreach</span>(var tile <span class="keywordflow">in</span> tilesToMark)</div><div class="line">    {</div><div class="line">        tileObjects[tile.Index].GetComponent&lt;Renderer&gt;().material = materials[1]; <span class="comment">// we color the marked tiles</span></div><div class="line">    }</div><div class="line">    tileObjects[selectedTileA.Index].GetComponent&lt;Renderer&gt;().material = materials[2]; <span class="comment">// we color the origin tile</span></div><div class="line">    <span class="keywordflow">if</span>(toolMode == ToolMode.Line) tileObjects[selectedTileB.Index].GetComponent&lt;Renderer&gt;().material = materials[3]; <span class="comment">// we color the target tile (line only)</span></div><div class="line">}</div></div><!-- fragment --><p>The completed example is also included in the package, just open the MinimalExample2 scene. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
